"""
STATUSES: not started, cooking, cooked, finished

BUENO HTTP POST /

```
    order: [
        {
            dish: string
            quantity: number
        }, ...
    ]
```

RESPONSE:

```
    {
        id: string,  // generated by restaurant
        status: string
    }
```

WEBHOOK HTTP POST <SELECT>

```
    {
        id: string,
        status: string
    }
```

=================================================================

STATUS: not started, cooking, cooked, finished

MELANGE HTTP POST /api/orders

```
    order: [
        {
            dish: string
            quantity: number
        }, ...
    ]
```

```
    {
        id: string,
        status: string
    }
```

MELANGE HTTP GET /api/orders/<ID>

```
    {
        status: string
    }
```
"""

from collections import defaultdict
from datetime import datetime, date, time
import json
from time import sleep
import uuid
import httpx
from shared.cache import CacheService
from celery import shared_task
from .models import Restaurant, Order, DishOrderItem
from .enums import Restaurant
from config import celery_app
from .models import ExternalOrder

@celery_app.task
def melange_order_processing(order_id: int):
    order = Order.objects.prefetch_related("items__dish__restaurant").get(id=order_id)
    melange_items = [
        {
            "dish": item.dish.name,
            "quantity": item.quantity,
        }
        for item in order.items.all()
        if item.dish.restaurant.name.lower() == Restaurant.MELANGE
    ]

    external_order, created = ExternalOrder.objects.get_or_create(
        order=order,
        provider=Restaurant.MELANGE,
        defaults={
            "external_id": "",
            "status": "not_started",
        }
    )

    while external_order.status != "finished":
        if external_order.status == "not_started":
            if not external_order.external_id:
                payload = {"order": melange_items}
                response = httpx.post("http://localhost:8001/api/orders", json=payload)
                response.raise_for_status()
                external_order.external_id = response.json()["id"]
                external_order.save()
            else:
                response = httpx.get(
                    f"http://localhost:8001/api/orders/{external_order.external_id}"
                )
                response.raise_for_status()
                external_order.status = response.json()["status"]
                external_order.save()
                print(f"Current status: {external_order.status}. Waiting 1 second")
                sleep(1)

        elif external_order.status == "cooking":
            response = httpx.get(
                f"http://localhost:8001/api/orders/{external_order.external_id}"
            )
            response.raise_for_status()
            external_order.status = response.json()["status"]
            external_order.save()
            print(f"Current status: {external_order.status}. Waiting 3 seconds")
            sleep(3)

        elif external_order.status == "cooked":
            print(f"ðŸšš CALLING DELIVERY SERVICE TO PASS THE FOOD ORDER")
            external_order.status = "finished"
            external_order.save()

        else:
            raise ValueError(f"Status {external_order.status} is not supported")


def bueno_order_processing(order_id: int):
    print("BUENO===============================")
    print(order_id)
    print("BUENO===============================")


@celery_app.task
def _schedule_order(order: Order):
    for item in order.items.all():
        restaurant_name = item.dish.restaurant.name.lower()

        if restaurant_name == Restaurant.MELANGE:
            melange_order_processing.delay(order.id)

        elif restaurant_name == Restaurant.BUENO:
            raise NotImplementedError(f"Restaurant Bueno is unsupported")

        else:
            raise ValueError(f"Unsupported restaurant: {restaurant_name}")


def schedule_order(order: Order):
    """Add the task to the queue for the future processing."""

    assert type(order.eta) is date

    # todo: remove

    _schedule_order(order)

    return None

    # 2025-03-06  -> 2025-03-06-00:00:00 UTC

    if order.eta == date.today():
        print(f"The order will be started processing now")
        return schedule_order_task.delay(order)
    else:
        # ETA: 3:00AM will be sent to restaurant APIs
        eta = datetime.combine(order.eta, time(hour=3))
        print(f"The order will be started processing {eta}")
        return schedule_order_task.apply_async(args=(order,), eta=eta)
